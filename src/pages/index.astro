---
import '../styles/global.css';
import SEOHead from '../components/SEOHead.astro';
import { SITE_CONFIG } from '../config/site';
---

<!doctype html>
<html lang="no">
  <head>
    <SEOHead 
      title={SITE_CONFIG.name}
      description={SITE_CONFIG.description}
      type="website"
    />
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        min-height: 100vh;
        display: flex;
        align-items: center;
        justify-content: center;
        background: #050a12;
        overflow: hidden;
        font-family: 'Segoe UI', system-ui, sans-serif;
      }

      .container {
        position: relative;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        z-index: 10;
      }

      #neural-canvas {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 1;
      }

      .logo-wrapper {
        position: relative;
        padding: 60px 80px;
        z-index: 10;
      }

      .glow-layer {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 500px;
        height: 250px;
        border-radius: 50%;
        filter: blur(80px);
        opacity: 0;
        z-index: -1;
      }

      .glow-1 {
        background: radial-gradient(ellipse, rgba(100, 160, 220, 0.3) 0%, transparent 70%);
        animation: glowPulse1 5s ease-in-out infinite;
      }

      .glow-2 {
        background: radial-gradient(ellipse, rgba(140, 180, 230, 0.2) 0%, transparent 70%);
        animation: glowPulse2 5s ease-in-out infinite 1.5s;
      }

      @keyframes glowPulse1 {
        0%, 100% { opacity: 0.4; transform: translate(-50%, -50%) scale(1); }
        50% { opacity: 0.8; transform: translate(-50%, -50%) scale(1.15); }
      }

      @keyframes glowPulse2 {
        0%, 100% { opacity: 0.3; transform: translate(-50%, -50%) scale(1.1); }
        50% { opacity: 0.6; transform: translate(-50%, -50%) scale(1.3); }
      }

      .logo-svg {
        filter: drop-shadow(0 0 30px rgba(180, 210, 240, 0.4));
        animation: logoPulse 5s ease-in-out infinite;
      }

      @keyframes logoPulse {
        0%, 100% { 
          filter: drop-shadow(0 0 20px rgba(180, 210, 240, 0.3)) 
                  drop-shadow(0 0 40px rgba(100, 160, 220, 0.15));
          transform: scale(1);
        }
        50% { 
          filter: drop-shadow(0 0 35px rgba(200, 225, 250, 0.5)) 
                  drop-shadow(0 0 60px rgba(120, 180, 230, 0.25));
          transform: scale(1.015);
        }
      }

      @media (prefers-reduced-motion: reduce) {
        .glow-1,
        .glow-2,
        .logo-svg {
          animation: none;
        }
        .glow-1,
        .glow-2 {
          opacity: 0.5;
        }
      }
    </style>
  </head>
  <body>
    <canvas id="neural-canvas"></canvas>
    
    <div class="container">
      <div class="logo-wrapper">
        <div class="glow-layer glow-1"></div>
        <div class="glow-layer glow-2"></div>
        
        <svg class="logo-svg" width="500" height="141" viewBox="0 0 500 141" fill="none" xmlns="http://www.w3.org/2000/svg">
          <defs>
            <linearGradient id="logoGradient" x1="0%" y1="0%" x2="100%" y2="100%">
              <stop offset="0%" style="stop-color:#d8ebf8">
                <animate attributeName="stop-color" values="#d8ebf8;#f0f8fc;#d8ebf8" dur="5s" repeatCount="indefinite"/>
              </stop>
              <stop offset="50%" style="stop-color:#e8f2fa">
                <animate attributeName="stop-color" values="#e8f2fa;#ffffff;#e8f2fa" dur="5s" repeatCount="indefinite"/>
              </stop>
              <stop offset="100%" style="stop-color:#d8ebf8">
                <animate attributeName="stop-color" values="#d8ebf8;#f0f8fc;#d8ebf8" dur="5s" repeatCount="indefinite"/>
              </stop>
            </linearGradient>
          </defs>
          <g transform="translate(126.24, 35.59) scale(1.5)">
            <g>
              <path d="M30.8184 8.11475H9.84082V19.2056H28.7725V27.3188H9.84082V46.5464H0V15.5005L15.499 0.00146484H30.8184V8.11475ZM0 11.2583V0.00146484H11.2568L0 11.2583Z" fill="url(#logoGradient)" />
              <path d="M34.71 0H45.7327L56.3463 20.0455H56.8009L67.4145 0H78.4372L61.46 30.0909V46.5455H51.6872V30.0909L34.71 0Z" fill="url(#logoGradient)" />
              <path d="M83.8125 46.5455V0H102.176C105.691 0 108.691 0.628788 111.176 1.88636C113.676 3.12879 115.578 4.89394 116.881 7.18182C118.199 9.45455 118.858 12.1288 118.858 15.2045C118.858 18.2955 118.191 20.9545 116.858 23.1818C115.525 25.3939 113.593 27.0909 111.062 28.2727C108.547 29.4545 105.502 30.0455 101.926 30.0455H89.6307V22.1364H100.335C102.214 22.1364 103.775 21.8788 105.017 21.3636C106.259 20.8485 107.184 20.0758 107.79 19.0455C108.411 18.0152 108.722 16.7348 108.722 15.2045C108.722 13.6591 108.411 12.3561 107.79 11.2955C107.184 10.2348 106.252 9.43182 104.994 8.88636C103.752 8.32576 102.184 8.04546 100.29 8.04546H93.6534V46.5455H83.8125ZM108.949 25.3636L120.517 46.5455H109.653L98.3352 25.3636H108.949Z" fill="url(#logoGradient)" />
              <path d="M125.812 46.5455V0H135.653V20.5227H136.267L153.017 0H164.812L147.54 20.8409L165.017 46.5455H153.244L140.494 27.4091L135.653 33.3182V46.5455H125.812Z" fill="url(#logoGradient)" />
            </g>
          </g>
        </svg>
      </div>
    </div>

    <script>
      // @ts-nocheck
      (function() {
        'use strict';
        
        var canvas = document.getElementById('neural-canvas');
        var ctx = canvas.getContext('2d');

        var width = 0;
        var height = 0;
        var nodes = [];
        var signals = [];
        var time = 0;

        function resize() {
          width = canvas.width = window.innerWidth;
          height = canvas.height = window.innerHeight;
          initNetwork();
        }

        function initNetwork() {
          nodes = [];
          signals = [];
          
          var layers = 8;
          var nodesPerLayer = [8, 14, 22, 30, 30, 22, 14, 8];
          
          for (var layer = 0; layer < layers; layer++) {
            var layerX = (width * 0.08) + (layer / (layers - 1)) * (width * 0.84);
            var nodeCount = nodesPerLayer[layer];
            
            for (var i = 0; i < nodeCount; i++) {
              var baseY = (height * 0.1) + (i / Math.max(1, nodeCount - 1)) * (height * 0.8);
              var jitterX = (Math.random() - 0.5) * (width * 0.08);
              var jitterY = (Math.random() - 0.5) * (height * 0.06);
              
              nodes.push({
                x: layerX + jitterX,
                y: baseY + jitterY,
                layer: layer,
                connections: [],
                activation: 0,
                baseActivation: Math.random() * 0.15,
                phase: Math.random() * Math.PI * 2,
                vx: 0,
                vy: 0,
                tvx: 0,
                tvy: 0,
                size: 1.5 + Math.random() * 2
              });
            }
          }
          
          // Create connections
          for (var n = 0; n < nodes.length; n++) {
            var node = nodes[n];
            var nextLayerNodes = [];
            
            for (var m = 0; m < nodes.length; m++) {
              if (nodes[m].layer === node.layer + 1) {
                nextLayerNodes.push({ idx: m, dist: Math.hypot(nodes[m].x - node.x, nodes[m].y - node.y) });
              }
            }
            
            nextLayerNodes.sort(function(a, b) { return a.dist - b.dist; });
            
            var connectionCount = 2 + Math.floor(Math.random() * 4);
            for (var c = 0; c < Math.min(connectionCount, nextLayerNodes.length); c++) {
              if (Math.random() > 0.2 || c < 2) {
                node.connections.push(nextLayerNodes[c].idx);
              }
            }
          }
        }

        function spawnSignal() {
          var inputNodes = [];
          for (var i = 0; i < nodes.length; i++) {
            if (nodes[i].layer === 0) inputNodes.push(i);
          }
          
          if (inputNodes.length === 0) return;
          
          var sourceIdx = inputNodes[Math.floor(Math.random() * inputNodes.length)];
          var sourceNode = nodes[sourceIdx];
          
          if (sourceNode.connections.length > 0) {
            var targetIdx = sourceNode.connections[Math.floor(Math.random() * sourceNode.connections.length)];
            
            signals.push({
              fromIdx: sourceIdx,
              toIdx: targetIdx,
              progress: 0,
              speed: 0.008 + Math.random() * 0.012,
              r: 70 + Math.floor(Math.random() * 30),
              g: 80 + Math.floor(Math.random() * 30),
              b: 100 + Math.floor(Math.random() * 40),
              intensity: 0.4 + Math.random() * 0.6,
              lineWidth: 1 + Math.random() * 2
            });
            
            sourceNode.activation = 1;
          }
        }

        function updateSignals() {
          var newSignals = [];
          
          for (var s = 0; s < signals.length; s++) {
            var signal = signals[s];
            signal.progress += signal.speed;
            
            if (signal.progress >= 1) {
              var targetNode = nodes[signal.toIdx];
              if (targetNode) {
                targetNode.activation = Math.min(1, targetNode.activation + signal.intensity * 0.8);
                
                // Cascade
                if (targetNode.connections.length > 0 && Math.random() > 0.15) {
                  var splits = Math.random() > 0.6 ? Math.min(3, targetNode.connections.length) : Math.ceil(targetNode.connections.length * 0.4);
                  
                  for (var i = 0; i < splits && i < targetNode.connections.length; i++) {
                    if (Math.random() > 0.3) {
                      var nextTarget = targetNode.connections[Math.floor(Math.random() * targetNode.connections.length)];
                      var toNode = nodes[nextTarget];
                      
                      if (toNode) {
                        var layerRatio = (targetNode.layer + toNode.layer) / 14;
                        
                        newSignals.push({
                          fromIdx: signal.toIdx,
                          toIdx: nextTarget,
                          progress: 0,
                          speed: 0.006 + Math.random() * 0.014,
                          r: Math.floor(70 + layerRatio * 130),
                          g: Math.floor(90 + layerRatio * 130),
                          b: Math.floor(120 + layerRatio * 100),
                          intensity: signal.intensity * (0.6 + Math.random() * 0.4),
                          lineWidth: signal.lineWidth * (0.7 + Math.random() * 0.3)
                        });
                      }
                    }
                  }
                }
              }
            } else {
              newSignals.push(signal);
            }
          }
          
          signals = newSignals;
          
          if (Math.random() > 0.92) {
            spawnSignal();
          }
          
          if (Math.random() > 0.995) {
            for (var b = 0; b < 3 + Math.floor(Math.random() * 5); b++) {
              spawnSignal();
            }
          }
        }

        function updateNodes() {
          for (var i = 0; i < nodes.length; i++) {
            var node = nodes[i];
            node.activation *= 0.96;
            
            if (Math.random() > 0.98) {
              node.tvx = (Math.random() - 0.5) * 3;
              node.tvy = (Math.random() - 0.5) * 3;
            }
            node.vx += (node.tvx - node.vx) * 0.1;
            node.vy += (node.tvy - node.vy) * 0.1;
            node.tvx *= 0.95;
            node.tvy *= 0.95;
          }
        }

        function getBezierPoint(t, p0x, p0y, p1x, p1y, p2x, p2y) {
          var mt = 1 - t;
          return {
            x: mt * mt * p0x + 2 * mt * t * p1x + t * t * p2x,
            y: mt * mt * p0y + 2 * mt * t * p1y + t * t * p2y
          };
        }

        function draw() {
          ctx.clearRect(0, 0, width, height);
          
          time += 0.016;
          
          // Draw connections
          for (var n = 0; n < nodes.length; n++) {
            var node = nodes[n];
            for (var c = 0; c < node.connections.length; c++) {
              var target = nodes[node.connections[c]];
              if (!target) continue;
              
              var combinedActivation = node.activation + target.activation;
              var alpha = 0.03 + combinedActivation * 0.15;
              
              var fromX = node.x + node.vx;
              var fromY = node.y + node.vy;
              var toX = target.x + target.vx;
              var toY = target.y + target.vy;
              
              var dx = toX - fromX;
              var dy = toY - fromY;
              var midX = fromX + dx * 0.5 + Math.sin(time * 0.5 + node.x * 0.01) * dy * 0.05;
              var midY = fromY + dy * 0.5 + Math.sin(time * 0.5 + node.y * 0.01) * dx * 0.05;
              
              var layerRatio = (node.layer + target.layer) / 14;
              var r = Math.floor(60 + layerRatio * 80);
              var g = Math.floor(80 + layerRatio * 100);
              var b = Math.floor(120 + layerRatio * 80);
              
              ctx.beginPath();
              ctx.moveTo(fromX, fromY);
              ctx.quadraticCurveTo(midX, midY, toX, toY);
              ctx.strokeStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + alpha + ')';
              ctx.lineWidth = 0.5;
              ctx.stroke();
            }
          }
          
          // Draw signals
          for (var s = 0; s < signals.length; s++) {
            var signal = signals[s];
            var from = nodes[signal.fromIdx];
            var to = nodes[signal.toIdx];
            
            if (!from || !to) continue;
            
            var fromX = from.x + from.vx;
            var fromY = from.y + from.vy;
            var toX = to.x + to.vx;
            var toY = to.y + to.vy;
            
            var dx = toX - fromX;
            var dy = toY - fromY;
            var midX = fromX + dx * 0.5 + Math.sin(time * 0.5 + from.x * 0.01) * dy * 0.05;
            var midY = fromY + dy * 0.5 + Math.sin(time * 0.5 + from.y * 0.01) * dx * 0.05;
            
            // Draw trail
            for (var t = 0; t < 8; t++) {
              var trailT = Math.max(0, signal.progress - (t / 8) * 0.15);
              var pos = getBezierPoint(trailT, fromX, fromY, midX, midY, toX, toY);
              var trailAlpha = (1 - t / 8) * signal.intensity * 0.6;
              var trailSize = signal.lineWidth * (1 - t / 8 * 0.5);
              
              ctx.beginPath();
              ctx.arc(pos.x, pos.y, trailSize, 0, Math.PI * 2);
              ctx.fillStyle = 'rgba(' + signal.r + ',' + signal.g + ',' + signal.b + ',' + trailAlpha + ')';
              ctx.fill();
            }
            
            // Draw head
            var headPos = getBezierPoint(signal.progress, fromX, fromY, midX, midY, toX, toY);
            var glowSize = signal.lineWidth * 3;
            
            var gradient = ctx.createRadialGradient(headPos.x, headPos.y, 0, headPos.x, headPos.y, glowSize);
            gradient.addColorStop(0, 'rgba(' + signal.r + ',' + signal.g + ',' + signal.b + ',' + signal.intensity + ')');
            gradient.addColorStop(0.5, 'rgba(' + signal.r + ',' + signal.g + ',' + signal.b + ',' + (signal.intensity * 0.3) + ')');
            gradient.addColorStop(1, 'rgba(' + signal.r + ',' + signal.g + ',' + signal.b + ',0)');
            
            ctx.beginPath();
            ctx.arc(headPos.x, headPos.y, glowSize, 0, Math.PI * 2);
            ctx.fillStyle = gradient;
            ctx.fill();
          }
          
          // Draw nodes
          for (var i = 0; i < nodes.length; i++) {
            var node = nodes[i];
            var x = node.x + node.vx;
            var y = node.y + node.vy;
            
            var layerRatio = node.layer / 7;
            var activation = node.baseActivation + node.activation;
            
            var r = Math.floor(80 + layerRatio * 140 + activation * 50);
            var g = Math.floor(100 + layerRatio * 120 + activation * 50);
            var b = Math.floor(140 + layerRatio * 80 + activation * 30);
            
            if (activation > 0.2) {
              var glowSize = node.size * (3 + activation * 8);
              var gradient = ctx.createRadialGradient(x, y, 0, x, y, glowSize);
              gradient.addColorStop(0, 'rgba(' + r + ',' + g + ',' + b + ',' + (activation * 0.5) + ')');
              gradient.addColorStop(0.5, 'rgba(' + r + ',' + g + ',' + b + ',' + (activation * 0.15) + ')');
              gradient.addColorStop(1, 'rgba(' + r + ',' + g + ',' + b + ',0)');
              
              ctx.beginPath();
              ctx.arc(x, y, glowSize, 0, Math.PI * 2);
              ctx.fillStyle = gradient;
              ctx.fill();
            }
            
            var coreAlpha = 0.3 + activation * 0.7;
            var coreSize = node.size * (1 + activation * 0.5);
            
            ctx.beginPath();
            ctx.arc(x, y, coreSize, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(' + (r + 40) + ',' + (g + 40) + ',' + (b + 20) + ',' + coreAlpha + ')';
            ctx.fill();
            
            if (activation > 0.5) {
              ctx.beginPath();
              ctx.arc(x, y, coreSize * 0.5, 0, Math.PI * 2);
              ctx.fillStyle = 'rgba(255,255,255,' + ((activation - 0.5) * 0.8) + ')';
              ctx.fill();
            }
          }
          
          updateSignals();
          updateNodes();
          
          requestAnimationFrame(draw);
        }

        // Respect prefers-reduced-motion
        if (window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
          // Disable animations for users who prefer reduced motion
          return;
        }

        window.addEventListener('resize', resize);
        resize();
        
        // Initial signals
        for (var i = 0; i < 8; i++) {
          spawnSignal();
        }
        
        draw();
      })();
    </script>
  </body>
</html>
