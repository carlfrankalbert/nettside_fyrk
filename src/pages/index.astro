---
import '../styles/global.css';
import SEOHead from '../components/SEOHead.astro';
import { SITE_CONFIG } from '../config/site';
import { EXTERNAL_LINKS } from '../utils/links';
---

<!doctype html>
<html lang="no">
  <head>
    <SEOHead 
      title={SITE_CONFIG.name}
      description={SITE_CONFIG.description}
      type="website"
    />
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        min-height: 100vh;
        display: flex;
        align-items: center;
        justify-content: center;
        background: #02040b;
        overflow: hidden;
        font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
      }

      #neural-canvas {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 1;
      }

      /* Radial overlay: light center, dark edges */
      .center-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: radial-gradient(
          ellipse 70% 60% at 50% 50%,
          transparent 0%,
          rgba(2, 4, 11, 0.3) 40%,
          rgba(2, 4, 11, 0.7) 70%,
          rgba(2, 4, 11, 0.9) 100%
        );
        z-index: 2;
        pointer-events: none;
      }

      .container {
        position: relative;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        z-index: 10;
      }

      .logo-wrapper {
        position: relative;
        padding: 50px 70px;
      }

      .social-links {
        display: flex;
        gap: 1.5rem;
        margin-top: 2rem;
        justify-content: center;
      }

      .social-link {
        display: flex;
        align-items: center;
        justify-content: center;
        width: 44px;
        height: 44px;
        border-radius: 50%;
        background: rgba(60, 100, 140, 0.1);
        border: 1px solid rgba(120, 160, 200, 0.15);
        transition: all 0.3s ease;
      }

      .social-link:hover {
        background: rgba(60, 100, 140, 0.2);
        border-color: rgba(120, 160, 200, 0.3);
        transform: translateY(-2px);
      }

      .social-link:focus-visible {
        outline: 2px solid rgba(120, 160, 200, 0.5);
        outline-offset: 4px;
      }

      .social-link svg {
        width: 20px;
        height: 20px;
        fill: rgba(160, 196, 220, 0.8);
        transition: fill 0.3s ease;
      }

      .social-link:hover svg {
        fill: rgba(184, 212, 232, 1);
      }

      /* Soft glow rings behind logo */
      .glow-ring {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        border-radius: 50%;
        filter: blur(60px);
        pointer-events: none;
      }

      .glow-ring-1 {
        width: 380px;
        height: 180px;
        background: radial-gradient(ellipse, rgba(60, 100, 140, 0.12) 0%, transparent 70%);
        animation: glowRing1 12s ease-in-out infinite;
      }

      .glow-ring-2 {
        width: 320px;
        height: 150px;
        background: radial-gradient(ellipse, rgba(70, 120, 160, 0.08) 0%, transparent 70%);
        animation: glowRing2 12s ease-in-out infinite 4s;
      }

      @keyframes glowRing1 {
        0%, 100% { 
          opacity: 0.8; 
          transform: translate(-50%, -50%) scale(1); 
        }
        50% { 
          opacity: 1; 
          transform: translate(-50%, -50%) scale(1.03); 
        }
      }

      @keyframes glowRing2 {
        0%, 100% { 
          opacity: 0.6; 
          transform: translate(-50%, -50%) scale(1.01); 
        }
        50% { 
          opacity: 0.85; 
          transform: translate(-50%, -50%) scale(1.045); 
        }
      }

      .logo-svg {
        display: block;
        filter: drop-shadow(0 0 12px rgba(120, 160, 200, 0.15));
        animation: logoPulse 12s ease-in-out infinite;
      }

      @keyframes logoPulse {
        0%, 100% { 
          filter: drop-shadow(0 0 10px rgba(120, 160, 200, 0.12));
          transform: scale(1);
        }
        50% { 
          filter: drop-shadow(0 0 16px rgba(130, 170, 210, 0.18));
          transform: scale(1.005);
        }
      }

      /* Reduced motion overrides */
      @media (prefers-reduced-motion: reduce) {
        .glow-ring-1, .glow-ring-2 {
          animation: none;
          opacity: 0.7;
        }
        
        .logo-svg {
          animation: none;
          filter: drop-shadow(0 0 10px rgba(120, 160, 200, 0.12));
        }
      }
    </style>
  </head>
  <body>
    <canvas id="neural-canvas"></canvas>
    <div class="center-overlay"></div>
    
    <div class="container">
      <div class="logo-wrapper">
        <div class="glow-ring glow-ring-1"></div>
        <div class="glow-ring glow-ring-2"></div>

        <svg class="logo-svg" width="500" height="141" viewBox="0 0 500 141" fill="none" xmlns="http://www.w3.org/2000/svg">
          <defs>
            <linearGradient id="logoGradient" x1="0%" y1="0%" x2="100%" y2="100%">
              <stop offset="0%" style="stop-color:#a0c4dc">
                <animate attributeName="stop-color" values="#a0c4dc;#b8d4e8;#a0c4dc" dur="12s" repeatCount="indefinite"/>
              </stop>
              <stop offset="50%" style="stop-color:#b0d0e4">
                <animate attributeName="stop-color" values="#b0d0e4;#c8e0f0;#b0d0e4" dur="12s" repeatCount="indefinite"/>
              </stop>
              <stop offset="100%" style="stop-color:#a0c4dc">
                <animate attributeName="stop-color" values="#a0c4dc;#b8d4e8;#a0c4dc" dur="12s" repeatCount="indefinite"/>
              </stop>
            </linearGradient>
          </defs>
          <g transform="translate(126.24, 35.59) scale(1.5)">
            <path d="M30.8184 8.11475H9.84082V19.2056H28.7725V27.3188H9.84082V46.5464H0V15.5005L15.499 0.00146484H30.8184V8.11475ZM0 11.2583V0.00146484H11.2568L0 11.2583Z" fill="url(#logoGradient)" />
            <path d="M34.71 0H45.7327L56.3463 20.0455H56.8009L67.4145 0H78.4372L61.46 30.0909V46.5455H51.6872V30.0909L34.71 0Z" fill="url(#logoGradient)" />
            <path d="M83.8125 46.5455V0H102.176C105.691 0 108.691 0.628788 111.176 1.88636C113.676 3.12879 115.578 4.89394 116.881 7.18182C118.199 9.45455 118.858 12.1288 118.858 15.2045C118.858 18.2955 118.191 20.9545 116.858 23.1818C115.525 25.3939 113.593 27.0909 111.062 28.2727C108.547 29.4545 105.502 30.0455 101.926 30.0455H89.6307V22.1364H100.335C102.214 22.1364 103.775 21.8788 105.017 21.3636C106.259 20.8485 107.184 20.0758 107.79 19.0455C108.411 18.0152 108.722 16.7348 108.722 15.2045C108.722 13.6591 108.411 12.3561 107.79 11.2955C107.184 10.2348 106.252 9.43182 104.994 8.88636C103.752 8.32576 102.184 8.04546 100.29 8.04546H93.6534V46.5455H83.8125ZM108.949 25.3636L120.517 46.5455H109.653L98.3352 25.3636H108.949Z" fill="url(#logoGradient)" />
            <path d="M125.812 46.5455V0H135.653V20.5227H136.267L153.017 0H164.812L147.54 20.8409L165.017 46.5455H153.244L140.494 27.4091L135.653 33.3182V46.5455H125.812Z" fill="url(#logoGradient)" />
          </g>
        </svg>
      </div>

      <div class="social-links">
        <a
          href={EXTERNAL_LINKS.email}
          class="social-link"
          aria-label="Send e-post til hei@fyrk.no"
        >
          <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
            <path d="M20 4H4C2.9 4 2.01 4.9 2.01 6L2 18C2 19.1 2.9 20 4 20H20C21.1 20 22 19.1 22 18V6C22 4.9 21.1 4 20 4ZM20 8L12 13L4 8V6L12 11L20 6V8Z"/>
          </svg>
        </a>
        <a
          href={EXTERNAL_LINKS.linkedin}
          class="social-link"
          aria-label="Besøk FYRK på LinkedIn"
          target="_blank"
          rel="noopener noreferrer"
        >
          <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
            <path d="M19 3A2 2 0 0 1 21 5V19A2 2 0 0 1 19 21H5A2 2 0 0 1 3 19V5A2 2 0 0 1 5 3H19M18.5 18.5V13.2A3.26 3.26 0 0 0 15.24 9.94C14.39 9.94 13.4 10.46 12.92 11.24V10.13H10.13V18.5H12.92V13.57C12.92 12.8 13.54 12.17 14.31 12.17A1.4 1.4 0 0 1 15.71 13.57V18.5H18.5M6.88 8.56A1.68 1.68 0 0 0 8.56 6.88C8.56 5.95 7.81 5.19 6.88 5.19A1.69 1.69 0 0 0 5.19 6.88C5.19 7.81 5.95 8.56 6.88 8.56M8.27 18.5V10.13H5.5V18.5H8.27Z"/>
          </svg>
        </a>
      </div>
    </div>

    <script>
      // @ts-nocheck
      (function() {
        'use strict';
        
        // ===========================================
        // CONFIGURATION PRESETS
        // ===========================================
        
        var PRESETS = {
          calm: {
            // Network structure
            nodeCount: 80,
            connectionMaxDist: 0.14,        // % of min(width, height)
            centerBias: 0.7,                // Higher = more nodes toward center
            
            // Visual intensity
            lineBaseAlpha: 0.025,
            lineActiveAlpha: 0.08,
            lineWidth: 0.5,
            nodeBaseAlpha: 0.18,
            nodeActiveAlpha: 0.5,
            nodeBaseSize: 1.3,
            nodeGlowSize: 2.0,
            
            // Signal behavior
            signalSpawnInterval: 2800,      // ms between spawns (average)
            signalSpawnVariance: 1500,      // +/- variance
            signalSpeed: 0.003,
            signalSpeedVariance: 0.002,
            signalCascadeChance: 0.35,      // Chance to continue at node
            signalIntensity: 0.45,
            signalTrailLength: 0.28,
            signalTrailSteps: 14,
            
            // Movement
            nodeJitterAmount: 1.0,
            nodeJitterSpeed: 0.03,
            nodeJitterChance: 0.003,
            timeIncrement: 0.008,
            
            // Colors (RGB)
            lineColor: { r: 50, g: 80, b: 120 },
            nodeColor: { r: 70, g: 110, b: 150 },
            signalColor: { r: 80, g: 130, b: 180 }
          },
          
          ultraCalm: {
            nodeCount: 55,
            connectionMaxDist: 0.12,
            centerBias: 0.75,
            
            lineBaseAlpha: 0.018,
            lineActiveAlpha: 0.05,
            lineWidth: 0.4,
            nodeBaseAlpha: 0.12,
            nodeActiveAlpha: 0.35,
            nodeBaseSize: 1.1,
            nodeGlowSize: 1.5,
            
            signalSpawnInterval: 4500,
            signalSpawnVariance: 2000,
            signalSpeed: 0.002,
            signalSpeedVariance: 0.001,
            signalCascadeChance: 0.2,
            signalIntensity: 0.35,
            signalTrailLength: 0.22,
            signalTrailSteps: 10,
            
            nodeJitterAmount: 0.5,
            nodeJitterSpeed: 0.02,
            nodeJitterChance: 0.002,
            timeIncrement: 0.005,
            
            lineColor: { r: 45, g: 70, b: 105 },
            nodeColor: { r: 60, g: 95, b: 130 },
            signalColor: { r: 70, g: 115, b: 160 }
          },
          
          reducedMotion: {
            nodeCount: 50,
            connectionMaxDist: 0.12,
            centerBias: 0.7,
            
            lineBaseAlpha: 0.02,
            lineActiveAlpha: 0.02,
            lineWidth: 0.4,
            nodeBaseAlpha: 0.15,
            nodeActiveAlpha: 0.15,
            nodeBaseSize: 1.2,
            nodeGlowSize: 0,
            
            signalSpawnInterval: 999999,    // Effectively never
            signalSpawnVariance: 0,
            signalSpeed: 0,
            signalSpeedVariance: 0,
            signalCascadeChance: 0,
            signalIntensity: 0,
            signalTrailLength: 0,
            signalTrailSteps: 0,
            
            nodeJitterAmount: 0,
            nodeJitterSpeed: 0,
            nodeJitterChance: 0,
            timeIncrement: 0.002,
            
            lineColor: { r: 45, g: 70, b: 105 },
            nodeColor: { r: 60, g: 95, b: 130 },
            signalColor: { r: 70, g: 115, b: 160 }
          }
        };
        
        // ===========================================
        // STATE
        // ===========================================
        
        var canvas = document.getElementById('neural-canvas');
        var ctx = canvas.getContext('2d');
        
        var width = 0;
        var height = 0;
        var centerX = 0;
        var centerY = 0;
        var nodes = [];
        var signals = [];
        var time = 0;
        var lastSignalSpawn = 0;
        var nextSignalDelay = 0;
        
        var prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
        var currentMode = prefersReducedMotion ? 'reducedMotion' : 'calm';
        var config = PRESETS[currentMode];
        
        // ===========================================
        // INITIALIZATION
        // ===========================================
        
        function resize() {
          width = canvas.width = window.innerWidth;
          height = canvas.height = window.innerHeight;
          centerX = width / 2;
          centerY = height / 2;
          initNetwork();
        }
        
        function initNetwork() {
          nodes = [];
          signals = [];
          
          var padding = 50;
          var maxRadius = Math.min(width, height) * 0.48;
          
          for (var i = 0; i < config.nodeCount; i++) {
            // Distribute with bias toward center
            var angle = Math.random() * Math.PI * 2;
            var radiusFactor = Math.pow(Math.random(), config.centerBias);
            var radius = radiusFactor * maxRadius;
            
            // Add some organic scatter
            var scatterX = (Math.random() - 0.5) * width * 0.15;
            var scatterY = (Math.random() - 0.5) * height * 0.15;
            
            var x = centerX + Math.cos(angle) * radius + scatterX;
            var y = centerY + Math.sin(angle) * radius + scatterY;
            
            // Keep in bounds
            x = Math.max(padding, Math.min(width - padding, x));
            y = Math.max(padding, Math.min(height - padding, y));
            
            // Calculate distance from center for intensity falloff
            var distFromCenter = Math.hypot(x - centerX, y - centerY);
            var maxDist = Math.hypot(width / 2, height / 2);
            var centerFactor = 1 - (distFromCenter / maxDist) * 0.6;
            
            nodes.push({
              x: x,
              y: y,
              centerFactor: centerFactor,
              connections: [],
              activation: 0,
              vx: 0,
              vy: 0,
              targetVx: 0,
              targetVy: 0,
              size: config.nodeBaseSize + Math.random() * 0.8
            });
          }
          
          // Create connections based on distance
          var maxConnDist = Math.min(width, height) * config.connectionMaxDist;
          
          for (var n = 0; n < nodes.length; n++) {
            var node = nodes[n];
            var nearby = [];
            
            for (var m = 0; m < nodes.length; m++) {
              if (m === n) continue;
              var dist = Math.hypot(nodes[m].x - node.x, nodes[m].y - node.y);
              if (dist < maxConnDist) {
                nearby.push({ idx: m, dist: dist });
              }
            }
            
            // Sort by distance, connect to closest
            nearby.sort(function(a, b) { return a.dist - b.dist; });
            
            var maxConns = 2 + Math.floor(Math.random() * 3);
            for (var c = 0; c < Math.min(maxConns, nearby.length); c++) {
              // Avoid duplicate connections
              var targetIdx = nearby[c].idx;
              if (node.connections.indexOf(targetIdx) === -1) {
                node.connections.push(targetIdx);
              }
            }
          }
          
          // Schedule first signal
          scheduleNextSignal();
        }
        
        // ===========================================
        // SIGNAL MANAGEMENT
        // ===========================================
        
        function scheduleNextSignal() {
          nextSignalDelay = config.signalSpawnInterval + (Math.random() - 0.5) * 2 * config.signalSpawnVariance;
          lastSignalSpawn = performance.now();
        }
        
        function spawnSignal() {
          if (nodes.length === 0 || config.signalSpawnInterval > 99999) return;
          
          // Prefer spawning from nodes closer to center
          var candidates = [];
          for (var i = 0; i < nodes.length; i++) {
            if (nodes[i].connections.length > 0) {
              // Weight by center factor
              var weight = Math.ceil(nodes[i].centerFactor * 3);
              for (var w = 0; w < weight; w++) {
                candidates.push(i);
              }
            }
          }
          
          if (candidates.length === 0) return;
          
          var sourceIdx = candidates[Math.floor(Math.random() * candidates.length)];
          var sourceNode = nodes[sourceIdx];
          var targetIdx = sourceNode.connections[Math.floor(Math.random() * sourceNode.connections.length)];
          
          var col = config.signalColor;
          
          signals.push({
            fromIdx: sourceIdx,
            toIdx: targetIdx,
            progress: 0,
            speed: config.signalSpeed + Math.random() * config.signalSpeedVariance,
            r: col.r + Math.floor(Math.random() * 30),
            g: col.g + Math.floor(Math.random() * 30),
            b: col.b + Math.floor(Math.random() * 25),
            intensity: config.signalIntensity * (0.8 + Math.random() * 0.4),
            width: 1.2 + Math.random() * 0.8
          });
          
          sourceNode.activation = Math.min(1, sourceNode.activation + 0.5);
          scheduleNextSignal();
        }
        
        function updateSignals() {
          // Check if it's time to spawn
          var now = performance.now();
          if (now - lastSignalSpawn > nextSignalDelay) {
            spawnSignal();
          }
          
          var newSignals = [];
          
          for (var s = 0; s < signals.length; s++) {
            var signal = signals[s];
            signal.progress += signal.speed;
            
            if (signal.progress >= 1) {
              // Arrived at target
              var targetNode = nodes[signal.toIdx];
              if (targetNode) {
                targetNode.activation = Math.min(1, targetNode.activation + signal.intensity * 0.6);
                
                // Maybe cascade
                if (targetNode.connections.length > 0 && Math.random() < config.signalCascadeChance) {
                  // Pick a random connection that isn't where we came from
                  var validTargets = [];
                  for (var c = 0; c < targetNode.connections.length; c++) {
                    if (targetNode.connections[c] !== signal.fromIdx) {
                      validTargets.push(targetNode.connections[c]);
                    }
                  }
                  
                  if (validTargets.length > 0) {
                    var nextTarget = validTargets[Math.floor(Math.random() * validTargets.length)];
                    var col = config.signalColor;
                    
                    newSignals.push({
                      fromIdx: signal.toIdx,
                      toIdx: nextTarget,
                      progress: 0,
                      speed: config.signalSpeed + Math.random() * config.signalSpeedVariance,
                      r: Math.min(200, signal.r + Math.floor((Math.random() - 0.3) * 15)),
                      g: Math.min(210, signal.g + Math.floor((Math.random() - 0.3) * 15)),
                      b: Math.min(220, signal.b + Math.floor((Math.random() - 0.2) * 10)),
                      intensity: signal.intensity * (0.6 + Math.random() * 0.25),
                      width: signal.width * 0.85
                    });
                  }
                }
              }
            } else {
              newSignals.push(signal);
            }
          }
          
          signals = newSignals;
        }
        
        // ===========================================
        // NODE UPDATE
        // ===========================================
        
        function updateNodes() {
          for (var i = 0; i < nodes.length; i++) {
            var node = nodes[i];
            
            // Decay activation slowly
            node.activation *= 0.992;
            
            // Occasional gentle jitter
            if (Math.random() < config.nodeJitterChance) {
              node.targetVx = (Math.random() - 0.5) * config.nodeJitterAmount;
              node.targetVy = (Math.random() - 0.5) * config.nodeJitterAmount;
            }
            
            // Smooth movement toward target
            node.vx += (node.targetVx - node.vx) * config.nodeJitterSpeed;
            node.vy += (node.targetVy - node.vy) * config.nodeJitterSpeed;
            
            // Decay target
            node.targetVx *= 0.99;
            node.targetVy *= 0.99;
          }
        }
        
        // ===========================================
        // RENDERING
        // ===========================================
        
        function bezierPoint(t, p0x, p0y, p1x, p1y, p2x, p2y) {
          var mt = 1 - t;
          return {
            x: mt * mt * p0x + 2 * mt * t * p1x + t * t * p2x,
            y: mt * mt * p0y + 2 * mt * t * p1y + t * t * p2y
          };
        }
        
        function draw() {
          ctx.clearRect(0, 0, width, height);
          time += config.timeIncrement;
          
          var lineCol = config.lineColor;
          var nodeCol = config.nodeColor;
          
          // --- Draw connections ---
          for (var n = 0; n < nodes.length; n++) {
            var node = nodes[n];
            var nx = node.x + node.vx;
            var ny = node.y + node.vy;
            
            for (var c = 0; c < node.connections.length; c++) {
              var target = nodes[node.connections[c]];
              if (!target) continue;
              
              var tx = target.x + target.vx;
              var ty = target.y + target.vy;
              
              // Intensity based on activation and center factor
              var combinedActivation = (node.activation + target.activation) * 0.5;
              var centerAvg = (node.centerFactor + target.centerFactor) * 0.5;
              var alpha = (config.lineBaseAlpha + combinedActivation * config.lineActiveAlpha) * centerAvg;
              
              // Subtle curve
              var dx = tx - nx;
              var dy = ty - ny;
              var midX = nx + dx * 0.5 + Math.sin(time * 0.4 + node.x * 0.003) * dy * 0.02;
              var midY = ny + dy * 0.5 + Math.cos(time * 0.4 + node.y * 0.003) * dx * 0.02;
              
              ctx.beginPath();
              ctx.moveTo(nx, ny);
              ctx.quadraticCurveTo(midX, midY, tx, ty);
              ctx.strokeStyle = 'rgba(' + lineCol.r + ',' + lineCol.g + ',' + lineCol.b + ',' + alpha.toFixed(4) + ')';
              ctx.lineWidth = config.lineWidth;
              ctx.stroke();
            }
          }
          
          // --- Draw signals ---
          for (var s = 0; s < signals.length; s++) {
            var signal = signals[s];
            var from = nodes[signal.fromIdx];
            var to = nodes[signal.toIdx];
            if (!from || !to) continue;
            
            var fx = from.x + from.vx;
            var fy = from.y + from.vy;
            var tox = to.x + to.vx;
            var toy = to.y + to.vy;
            
            var dx = tox - fx;
            var dy = toy - fy;
            var midX = fx + dx * 0.5 + Math.sin(time * 0.4 + from.x * 0.003) * dy * 0.02;
            var midY = fy + dy * 0.5 + Math.cos(time * 0.4 + from.y * 0.003) * dx * 0.02;
            
            // Draw trail
            var steps = config.signalTrailSteps;
            var trailLen = config.signalTrailLength;
            
            for (var t = 0; t < steps; t++) {
              var trailT = Math.max(0, signal.progress - (t / steps) * trailLen);
              var pos = bezierPoint(trailT, fx, fy, midX, midY, tox, toy);
              var falloff = 1 - (t / steps);
              var trailAlpha = falloff * falloff * signal.intensity * 0.55;
              var trailSize = signal.width * (0.25 + falloff * 0.55);
              
              ctx.beginPath();
              ctx.arc(pos.x, pos.y, trailSize, 0, Math.PI * 2);
              ctx.fillStyle = 'rgba(' + signal.r + ',' + signal.g + ',' + signal.b + ',' + trailAlpha.toFixed(4) + ')';
              ctx.fill();
            }
            
            // Draw head
            var headPos = bezierPoint(signal.progress, fx, fy, midX, midY, tox, toy);
            var headSize = signal.width * 1.8;
            
            var grad = ctx.createRadialGradient(headPos.x, headPos.y, 0, headPos.x, headPos.y, headSize);
            grad.addColorStop(0, 'rgba(' + signal.r + ',' + signal.g + ',' + signal.b + ',' + (signal.intensity * 0.7).toFixed(4) + ')');
            grad.addColorStop(0.5, 'rgba(' + signal.r + ',' + signal.g + ',' + signal.b + ',' + (signal.intensity * 0.2).toFixed(4) + ')');
            grad.addColorStop(1, 'rgba(' + signal.r + ',' + signal.g + ',' + signal.b + ',0)');
            
            ctx.beginPath();
            ctx.arc(headPos.x, headPos.y, headSize, 0, Math.PI * 2);
            ctx.fillStyle = grad;
            ctx.fill();
          }
          
          // --- Draw nodes ---
          for (var i = 0; i < nodes.length; i++) {
            var node = nodes[i];
            var x = node.x + node.vx;
            var y = node.y + node.vy;
            
            var activation = node.activation;
            var cf = node.centerFactor;
            
            // Subtle glow for active nodes
            if (activation > 0.1 && config.nodeGlowSize > 0) {
              var glowSize = node.size * (config.nodeGlowSize + activation * 2.5);
              var glowAlpha = activation * 0.25 * cf;
              
              var glowGrad = ctx.createRadialGradient(x, y, 0, x, y, glowSize);
              glowGrad.addColorStop(0, 'rgba(' + nodeCol.r + ',' + nodeCol.g + ',' + nodeCol.b + ',' + glowAlpha.toFixed(4) + ')');
              glowGrad.addColorStop(0.5, 'rgba(' + nodeCol.r + ',' + nodeCol.g + ',' + nodeCol.b + ',' + (glowAlpha * 0.3).toFixed(4) + ')');
              glowGrad.addColorStop(1, 'rgba(' + nodeCol.r + ',' + nodeCol.g + ',' + nodeCol.b + ',0)');
              
              ctx.beginPath();
              ctx.arc(x, y, glowSize, 0, Math.PI * 2);
              ctx.fillStyle = glowGrad;
              ctx.fill();
            }
            
            // Node core
            var coreAlpha = (config.nodeBaseAlpha + activation * config.nodeActiveAlpha) * cf;
            var coreSize = node.size * (1 + activation * 0.2);
            
            ctx.beginPath();
            ctx.arc(x, y, coreSize, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(' + (nodeCol.r + 25) + ',' + (nodeCol.g + 25) + ',' + (nodeCol.b + 15) + ',' + coreAlpha.toFixed(4) + ')';
            ctx.fill();
          }
          
          updateSignals();
          updateNodes();
          
          requestAnimationFrame(draw);
        }
        
        // Listen for reduced motion preference changes
        window.matchMedia('(prefers-reduced-motion: reduce)').addEventListener('change', function(e) {
          prefersReducedMotion = e.matches;
          if (prefersReducedMotion) {
            currentMode = 'reducedMotion';
            config = PRESETS.reducedMotion;
            resize();
          } else {
            currentMode = 'calm';
            config = PRESETS.calm;
            resize();
          }
        });
        
        // ===========================================
        // INIT
        // ===========================================
        
        window.addEventListener('resize', resize);
        resize();
        draw();
      })();
    </script>
  </body>
</html>
